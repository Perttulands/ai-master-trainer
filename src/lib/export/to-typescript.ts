/**
 * Generated by Training Camp
 * TypeScript/Anthropic SDK Export Module
 *
 * Generates Anthropic SDK TypeScript code from an AgentDefinition.
 * The generated code uses the official @anthropic-ai/sdk package.
 */

import type { AgentDefinition, AgentTool } from '../../types/agent';

/**
 * Escapes a string for use in TypeScript template literals.
 */
function escapeTemplateString(str: string): string {
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
}

/**
 * Converts a JavaScript/TypeScript type to a JSON Schema type.
 */
function toJsonSchemaType(
  jsType: string
): 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array' {
  const typeMap: Record<
    string,
    'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array'
  > = {
    string: 'string',
    number: 'number',
    integer: 'integer',
    boolean: 'boolean',
    object: 'object',
    array: 'array',
  };
  return typeMap[jsType.toLowerCase()] || 'string';
}

/**
 * Generates the tool definition for the Anthropic SDK.
 */
function generateToolDefinition(tool: AgentTool): string {
  const properties = tool.parameters
    .map((p) => {
      return `        ${p.name}: {
          type: '${toJsonSchemaType(p.type)}',
          description: '${p.description.replace(/'/g, "\\'")}',
        }`;
    })
    .join(',\n');

  const required = tool.parameters
    .filter((p) => p.required)
    .map((p) => `'${p.name}'`)
    .join(', ');

  return `  {
    name: '${tool.name}',
    description: '${tool.description.replace(/'/g, "\\'")}',
    input_schema: {
      type: 'object' as const,
      properties: {
${properties}
      },
      required: [${required}],
    },
  }`;
}

/**
 * Generates the tool handler cases.
 */
function generateToolHandlers(tools: AgentTool[]): string {
  return tools
    .map((tool) => {
      const params = tool.parameters.map((p) => p.name).join(', ');
      return `      case '${tool.name}': {
        const { ${params} } = toolInput as { ${tool.parameters.map((p) => `${p.name}: ${p.type}`).join('; ')} };
        // TODO: Implement tool logic for ${tool.name}
        return JSON.stringify({ success: true, result: 'Tool ${tool.name} executed' });
      }`;
    })
    .join('\n');
}

/**
 * Exports an AgentDefinition to Anthropic SDK TypeScript code.
 *
 * @param agent - The agent definition to export
 * @returns A string containing the generated TypeScript code
 */
export function exportToTypeScript(agent: AgentDefinition): string {
  const toolDefinitions = agent.tools.map(generateToolDefinition).join(',\n');
  const toolHandlers = generateToolHandlers(agent.tools);

  const modelName = agent.parameters.model.includes('claude')
    ? agent.parameters.model
    : 'claude-sonnet-4-20250514';

  return `/**
 * Generated by Training Camp
 * Agent: ${agent.name}
 * Version: ${agent.version}
 * Description: ${agent.description}
 *
 * This file contains an Anthropic SDK agent implementation.
 */

import Anthropic from '@anthropic-ai/sdk';

// =============================================================================
// Configuration
// =============================================================================

const SYSTEM_PROMPT = \`${escapeTemplateString(agent.systemPrompt)}\`;

const MODEL = '${modelName}';
const MAX_TOKENS = ${agent.parameters.maxTokens};

// =============================================================================
// Tool Definitions
// =============================================================================

const tools: Anthropic.Tool[] = [
${toolDefinitions}
];

// =============================================================================
// Tool Handler
// =============================================================================

/**
 * Processes a tool call and returns the result.
 */
async function handleToolCall(
  toolName: string,
  toolInput: Record<string, unknown>
): Promise<string> {
  switch (toolName) {
${toolHandlers}
    default:
      return JSON.stringify({ error: \`Unknown tool: \${toolName}\` });
  }
}

// =============================================================================
// Response Processing
// =============================================================================

interface ProcessedResponse {
  content: string;
  toolCalls: Array<{
    id: string;
    name: string;
    input: Record<string, unknown>;
  }>;
  stopReason: string | null;
}

/**
 * Processes the API response and extracts content and tool calls.
 */
function processResponse(response: Anthropic.Message): ProcessedResponse {
  const content: string[] = [];
  const toolCalls: ProcessedResponse['toolCalls'] = [];

  for (const block of response.content) {
    if (block.type === 'text') {
      content.push(block.text);
    } else if (block.type === 'tool_use') {
      toolCalls.push({
        id: block.id,
        name: block.name,
        input: block.input as Record<string, unknown>,
      });
    }
  }

  return {
    content: content.join('\\n'),
    toolCalls,
    stopReason: response.stop_reason,
  };
}

// =============================================================================
// Agent Runner
// =============================================================================

/**
 * Runs the agent with the given user message.
 *
 * @param userMessage - The user's input message
 * @param conversationHistory - Optional previous conversation messages
 * @returns The agent's final response
 */
async function runAgent(
  userMessage: string,
  conversationHistory: Anthropic.MessageParam[] = []
): Promise<string> {
  const client = new Anthropic();

  const messages: Anthropic.MessageParam[] = [
    ...conversationHistory,
    { role: 'user', content: userMessage },
  ];

  let continueLoop = true;

  while (continueLoop) {
    const response = await client.messages.create({
      model: MODEL,
      max_tokens: MAX_TOKENS,
      system: SYSTEM_PROMPT,
      tools,
      messages,
    });

    const processed = processResponse(response);

    // If there are tool calls, process them
    if (processed.toolCalls.length > 0) {
      // Add assistant's response with tool use to messages
      messages.push({
        role: 'assistant',
        content: response.content,
      });

      // Process each tool call and add results
      const toolResults: Anthropic.ToolResultBlockParam[] = [];

      for (const toolCall of processed.toolCalls) {
        const result = await handleToolCall(toolCall.name, toolCall.input);
        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolCall.id,
          content: result,
        });
      }

      messages.push({
        role: 'user',
        content: toolResults,
      });
    } else {
      // No more tool calls, return the final response
      continueLoop = false;
      return processed.content;
    }

    // Safety check: stop if we hit end_turn
    if (response.stop_reason === 'end_turn' && processed.toolCalls.length === 0) {
      continueLoop = false;
      return processed.content;
    }
  }

  return '';
}

// =============================================================================
// Main Entry Point
// =============================================================================

async function main(): Promise<void> {
  console.log('${'='.repeat(60)}');
  console.log('${agent.name} v${agent.version}');
  console.log('${'='.repeat(60)}');
  console.log('${agent.description}');
  console.log('${'-'.repeat(60)}');
  console.log();

  // Example usage
  const response = await runAgent('Hello, how can you help me?');
  console.log('Agent:', response);
}

// Run if executed directly
main().catch(console.error);

export { runAgent, handleToolCall, processResponse, SYSTEM_PROMPT, tools };
`;
}
